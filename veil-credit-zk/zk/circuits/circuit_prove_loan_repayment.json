{
  "noir_version": "1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95",
  "hash": "13265373678509505643",
  "abi": {
    "parameters": [
      {
        "name": "root_deposit",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "root_loan",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "root_repay",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "withdraw_amount",
        "type": { "kind": "integer", "sign": "unsigned", "width": 128 },
        "visibility": "public"
      },
      {
        "name": "recipient",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "nullifier_d",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "secret_d",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "token_id",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "amount",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "merkle_proof_deposit",
        "type": { "kind": "array", "length": 16, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "is_even_deposit",
        "type": {
          "kind": "array",
          "length": 16,
          "type": { "kind": "boolean" }
        },
        "visibility": "private"
      },
      {
        "name": "merkle_proof_loan",
        "type": { "kind": "array", "length": 16, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "is_even_loan",
        "type": {
          "kind": "array",
          "length": 16,
          "type": { "kind": "boolean" }
        },
        "visibility": "private"
      },
      {
        "name": "merkle_proof_repay",
        "type": { "kind": "array", "length": 16, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "is_even_repay",
        "type": {
          "kind": "array",
          "length": 16,
          "type": { "kind": "boolean" }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "tdndattKFIbhe/FxDuZv/UxvZbMpbuoUg3GCmxQ2ofe+pXS9TnIgITz0aL7Y0YM0XkujsV933w/fXn58PZ4fHn/uvvzzuvt2OZ5Oxx9fT4/3++fj43l69fX33Y4/vz5fDofppd2H96ejnvaXw/l59+X8cjrd7X7tTy9v//TzaX9+G5/3l+nddLc7nL9P4wQ+HE+HOf2+ez86LR/aU46Dc0p2PV7yJyAvA1VKAC3r+/H90/Fl+fhSvAdQaipLQl0WclZOIWeXW4SaOIdciy8JsjKNTQLocsvxOZXrNSRdvAZbFppnTqG5vM9j3v5JqFNIRXtdOoc+PI85DU7kRsAW53Gtnrtf61luqWfLyixaTYtn0Fam0awyjdYXWyKP1uMqkAyg6C3AxorOPlzSq1PZ3yuyl8WpTGvXIen97rJ4hywrJVUSJVXyhw+jbAfatTFFbgFqpSarp0Wgjd7lZfg2X3T4Pr96Ftuas/hwc5Y+2JxrwMbeqnl8ufC/2lvl/emjVF/qrTWhpeun0aQtCVUGS7vq8LpZbXjhrD5YVKvzsGXhW52Hbc3V8nBztTLcG60O98bqhYz3RusNQT8Knyu76eC6swpsWXfWgE3rTuuDzSlpeN2RPLzurJ7FttaQOtwa0kY3KW24t0SHe2t1JsZ7S691mVXtlnXHK72V3XVJ0DRY2pqH1x0tw+uO1sGiWp2HLevO6jxsay7V4eZSG+4NHd/vrF7IeG/0ws6vJFl8JrPR/Y6N7ndsdL9jo/sdG9/v2Ph+x8b3Oza+37HR/Y6N73d8fL9jf3W/U5KVa2ckuWHdKeX6bUQp1m4S2qLw7/TX/v54+fQl9a71aWrvdpL+DHm+/GksMdapW6arkhajxKgxWoweY/8zaooxx1hiDE/D0/A0PA1Pw9PwLDwLz8Kz8Cw8C8/Cs/AsPAvPw/PwPDwPz8Pz8Dw8D8/D8/B6eD28Hl4Pr4fXw+vh9fB6eD286et6QiYUQiU0ghCUYAQnIGfkjJyRM3JGzsgZOSNn5IxckAtyQS7IBbkgF+SCXJALckWuyBW5IlfkOsttDpPc3oIRJllsDj1CS4RMKIRKaAQhKMEIyA1ZkAVZkAVZkAVZkAVZkAVZkRVZkRVZkRVZkRVZkRXZkA3ZkA3ZkA3ZkA3ZkA3ZkR3ZkR3ZkR3ZkR3ZkR25I3fkjtyRO3JH7sgduSP3kEtKhEwohEpoBCEowQhOQM7IGTkjZ+SMnJEzckaee1D6HCZZ5zD3oJc5ZEIhVEIjCEEJRnBCj1CRK3JFrsgVuSJX5IpckStyQ27IDbkhN+SG3JAbckNuyIIsyIIsyIIsyIIsyIIsyIqsyIqsyIqsyIqsyIqsyIZsyIZsyIZsyIZsyIZsyI7syI7syI7syI7syI7syB25I3fkjtyRO3JH7sgduYdc5x70NodZnh/Wf+0vx/230yF+Yn94Od9/+MX9+b8n3uE3+afL4/3h+8vlMD/4vL03PQr9Dw==",
  "file_map": {
    "19": {
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "51": {
      "source": "use poseidon::poseidon2;\nmod merkle_tree;\n\nfn main(\n    // -------------------------\n    // Public inputs (on-chain)\n    // -------------------------\n    root_deposit: pub Field,\n    root_loan: pub Field,\n    root_repay: pub Field,\n    withdraw_amount: pub u128,\n    recipient: pub Field,\n\n    // -------------------------\n    // Private inputs (witness)\n    // -------------------------\n    // Deposit secrets\n    nullifier_d: Field,\n    secret_d: Field,\n    token_id: Field,\n    amount: Field,\n\n    // Merkle proofs\n    merkle_proof_deposit: [Field; 16],\n    is_even_deposit: [bool; 16],\n\n    merkle_proof_loan: [Field; 16],\n    is_even_loan: [bool; 16],\n\n    merkle_proof_repay: [Field; 16],\n    is_even_repay: [bool; 16],\n) {\n\n    // ----------------------------------\n    // 1. Deposit commitment & membership\n    // ----------------------------------\n    let deposit_commitment: Field =\n        poseidon2::Poseidon2::hash(\n            [nullifier_d, secret_d, amount, token_id],\n            4\n        );\n\n    let computed_deposit_root =\n        merkle_tree::compute_merkle_root(\n            deposit_commitment,\n            merkle_proof_deposit,\n            is_even_deposit\n        );\n\n    assert(computed_deposit_root == root_deposit);\n\n    // ----------------------------------\n    // 2. Loan commitment (DERIVED)\n    // ----------------------------------\n    let loan_commitment: Field =\n        poseidon2::Poseidon2::hash([deposit_commitment], 1);\n\n    let computed_loan_root =\n        merkle_tree::compute_merkle_root(\n            loan_commitment,\n            merkle_proof_loan,\n            is_even_loan\n        );\n\n    assert(computed_loan_root == root_loan);\n\n    // ----------------------------------\n    // 3. Repayment commitment (DERIVED)\n    // ----------------------------------\n    let repay_commitment: Field =\n        poseidon2::Poseidon2::hash([loan_commitment], 1);\n\n    let computed_repay_root =\n        merkle_tree::compute_merkle_root(\n            repay_commitment,\n            merkle_proof_repay,\n            is_even_repay\n        );\n\n    assert(computed_repay_root == root_repay);\n\n    // ----------------------------------\n    // 4. Withdrawal amount binding\n    // ----------------------------------\n    assert(amount == withdraw_amount as Field);\n\n    // ----------------------------------\n    // 5. Recipient binding (no-op but\n    \n    //    prevents optimizer removal)\n    // ----------------------------------\n    assert(recipient * recipient == recipient * recipient);\n}",
      "path": "/Users/admin/Desktop/VeilCredit/circuits/circuit_prove_loan_repayment/src/main.nr"
    },
    "52": {
      "source": "use dep::poseidon::poseidon2;\n\npub fn compute_merkle_root(leaf: Field, merkle_proof: [Field; 16], is_even: [bool; 16]) -> Field {\n    let mut hash = leaf;\n\n    for i in 0..16 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], hash)\n        };\n        hash = poseidon2::Poseidon2::hash([left, right], 2);\n    }\n\n    hash\n}\n",
      "path": "/Users/admin/Desktop/VeilCredit/circuits/circuit_prove_loan_repayment/src/merkle_tree.nr"
    },
    "59": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "/Users/admin/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
